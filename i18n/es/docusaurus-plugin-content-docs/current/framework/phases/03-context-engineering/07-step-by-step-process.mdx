---
title: "El proceso paso a paso"
sidebar_label: "Paso a Paso"
slug: /framework/fases/context-engineering/proceso-paso-a-paso
description: "Un proceso estructurado con cinco pasos: establecer Reglas, diseñar la cadena de Agentes, generar documentos estratégicos, descomponer en Skills y validar a través de outputs."
sidebar_position: 1
tags: [fases, context-engineering, proceso, agentes, reglas, skills]
---

# El proceso paso a paso

El Context Engineering no es un ejercicio de escritura creativa. Es un proceso de traducción estructurado que convierte la comprensión humana capturada en las Fases 1 y 2 en un sistema que la IA puede procesar fielmente. Cada paso tiene un propósito claro, un entregable concreto y un criterio de validación.

## Paso 1. Establecer Reglas (project-context.md)

*Duración estimada: 1-2 días*

Las Reglas van primero porque todo depende de ellas. Un Agente sin Reglas improvisa. Un Skill sin Reglas produce resultados impredecibles. El project-context.md es la constitución que cada Agente carga antes de ejecutar cualquier Skill, no como referencia a consultar, sino como restricción que condiciona.

### Por dónde empezar

Toma el Solution Brief de la Fase 2 y extrae cada decisión que aplica globalmente. Las restricciones se convierten en Reglas. Las decisiones tecnológicas se convierten en Reglas. Las convenciones se convierten en Reglas. El Solution Brief contiene estas decisiones implícitamente, tu trabajo es hacerlas explícitas e inequívocas.

Piensa en ello como escribir el manual de empleado de una empresa. Los nuevos empleados no tienen años de conocimiento institucional. Necesitan todo por escrito: qué herramientas usar, qué está prohibido, cómo escalar problemas. Los Agentes de IA son empleados nuevos perpetuos, solo saben lo que está en el manual.

### Qué debe contener el project-context.md

| Sección | Qué incluye | Por qué importa |
|---|---|---|
| **Stack tecnológico** | Lenguajes, frameworks, versiones. | Un Agente que no conoce el stack podría escribir Python cuando el proyecto usa TypeScript. |
| **Convenciones de código** | Nomenclatura, estructura de archivos, patrones obligatorios. | Sin convenciones explícitas, dos Agentes producen código inconsistente, ambos correctos individualmente, incoherentes juntos. |
| **Restricciones de seguridad** | Qué está prohibido, qué requiere escalación. | Una sola violación de seguridad puede comprometer todo el proyecto. Siempre son Reglas de Nivel 5. |
| **Reglas de integración** | Cómo se comunican los componentes (REST, gRPC, eventos). | Cuando un Skill involucra integración, estas Reglas definen el cómo. |
| **Límites de Agentes** | Qué puede decidir cada Agente autónomamente y qué requiere escalación. | Previene que los Agentes tomen decisiones fuera de su rol, como un desarrollador que decide cambiar la base de datos sin consultar al arquitecto. |
| **Protocolo ante gaps** | "Cuando un Agente detecta información insuficiente en un Skill, señala el gap. No lo rellena." | Sin esto, los Agentes inventan respuestas con total confianza, creando Context Debt invisible. Es la Regla más importante. |
| **Decisiones globales justificadas** | Cada decisión transversal con su "por qué". | Si un Agente entiende *por qué* existe una Regla, puede aplicarla correctamente ante situaciones que el Context Engineer no previó. |

### Calibrar niveles de precisión

No todas las Reglas necesitan la misma rigidez. La clave es calibrar: invertir precisión donde el impacto sobre Agentes y Skills es alto, y delegar donde es bajo.

| Nivel | Tipo | Qué significa para Agentes y Skills | Ejemplo |
|---|---|---|---|
| **5** | Prescriptivo | Restricción absoluta. Ningún Agente puede violarla en ningún Skill. Si un Skill la contradice, el Agente debe escalar. | "Todos los endpoints devuelven JSON &#123; data, error, meta &#125;. Sin excepciones." |
| **4** | Específico | Cada Skill que toque esta área debe cumplir. Los Agentes la aplican sin interpretación. | "Alerta push al gerente en menos de 2 minutos cuando el stock cae bajo el umbral." |
| **3** | Dirigido | Los Agentes siguen la dirección. Los Skills pueden adaptarla al contexto específico. | "Tono informativo, sin tecnicismos. Adaptable según audiencia." |
| **2** | Orientativo | Preferencia, no mandato. Los Agentes la consideran; los Skills pueden desviarse si lo justifican. | "Preferimos tablas para datos de inventario. Otros formatos aceptables." |
| **1** | Delegado | El Context Engineer delega explícitamente al Agente. El Skill no prescribe; el Agente decide. | "camelCase para variables. Resto: criterio del Agente." |

Delegar no es olvidar. Es decidir qué no necesita prescripción. Los niveles 1-2 son delegaciones conscientes al Agente. Los niveles 4-5 son límites que ningún Agente puede cruzar en ningún Skill.

:::note Ejemplo práctico: Calibrando la precisión para un sistema de inventario
Una empresa de retail construyendo un sistema de gestión de inventario:

**Nivel 5 (Prescriptivo):** "Todas las cantidades de inventario son enteros. Nunca usar punto flotante para conteos de stock.", un solo float puede causar errores de redondeo que se propagan por toda la cadena de suministro.

**Nivel 4 (Específico):** "Las alertas de stock bajo se disparan en menos de 2 minutos tras superar el umbral.", el negocio prometió este SLA a los gerentes de tienda.

**Nivel 3 (Dirigido):** "Los mensajes de error son comprensibles para el usuario, no técnicos. Adaptar el lenguaje según la audiencia.", los errores para clientes difieren de los errores para administradores, pero ambos deben ser claros.

**Nivel 2 (Orientativo):** "Preferimos actualizaciones en tiempo real vía WebSocket para dashboards. REST aceptable donde WebSocket añade complejidad innecesaria.", preferencia de rendimiento, no restricción dura.

**Nivel 1 (Delegado):** "Convención de nombres CSS para componentes de UI: criterio del Agente.", decisión de bajo impacto que no afecta la coherencia del sistema.
:::

### La regla de las tres lecturas

Antes de pasar al Paso 2, aplica esta validación: un Agente que reciba únicamente el project-context.md debería poder responder tres preguntas:

1. **¿Qué tecnologías uso?** Si la respuesta no está, un Agente podría elegir el stack equivocado.
2. **¿Qué no puedo hacer?** Si las prohibiciones no son explícitas, los Agentes tomarán decisiones que parecen razonables localmente pero violan restricciones del proyecto.
3. **¿Cuál es la convención para cualquier patrón recurrente?** Si las convenciones de nombres, formato o arquitectura no están documentadas, cada Agente inventará las suyas.

Si alguna respuesta falta, las Reglas están incompletas.

## Paso 2. Diseñar la Cadena de Agentes

*Duración estimada: 1-2 días*

La traducción del Solution Brief al sistema de contexto completo la ejecuta una cadena de Agentes especializados. Piensa en ello como una línea de ensamblaje: cada estación recibe el trabajo de la anterior, le añade valor dentro de controles de calidad estrictos, y lo pasa a la siguiente.

### La cadena estándar

La mayoría de proyectos usan cinco Agentes en secuencia. Proyectos más simples pueden combinar roles; los más complejos pueden añadir especialistas. Pero la cadena de cinco Agentes cubre la gran mayoría de casos:

| Agente | Input | Qué hace | Output |
|---|---|---|---|
| **Analyst Agent** | Problem Statement + Solution Brief | Traduce artefactos humanos a requisitos estructurados. No descubre ni inventa, reformatea. | Documento de requisitos estructurado |
| **PM Agent** | Requisitos estructurados | Genera el PRD: qué construir, para quién, con qué prioridad. Define casos de uso. | PRD completo |
| **Architect Agent** | PRD | Traduce PRD a decisiones técnicas. Genera nuevas Reglas a partir de decisiones de arquitectura. | Architecture Document + nuevas Reglas en project-context.md |
| **SM Agent** | PRD + Architecture | Descompone la solución en Skills autocontenidos. Cada Skill incluye todo el contexto para su Agente ejecutor. | Story Files (Skills) |
| **QA Agent** | Output de cada Agente | Valida fidelidad, completitud, consistencia con Reglas. Verifica en cada eslabón de la cadena. | Informe de validación |

### Definir cada Agente con cinco elementos

Cada definición de Agente debe incluir cinco elementos. Si falta alguno, se crea un gap que aparecerá durante la ejecución:

1. **Identidad:** Quién es: rol, expertise, perspectiva. Determina cómo interpreta las Reglas y desde qué ángulo aborda los Skills.
2. **Responsabilidades:** Qué hace: tareas, outputs esperados. Define qué tipos de Skills puede ejecutar.
3. **Límites:** Qué NO hace. Tan importante como las responsabilidades. Previene que un Agente invada el territorio de otro.
4. **Reglas que aplica:** Referencia explícita al project-context.md. El Agente sabe qué Reglas cargar antes de ejecutar cualquier Skill.
5. **Protocolo ante gaps:** Qué hace cuando la información es insuficiente. La Regla crítica: señalar el gap, no inventar.

:::note Ejemplo práctico: Definición del Architect Agent
**Identidad:** Arquitecto técnico senior especializado en sistemas distribuidos. Piensa en términos de escalabilidad, mantenibilidad y coste operativo.

**Responsabilidades:** Traducir el PRD a decisiones técnicas. Producir el Architecture Document. Generar ADRs (Architecture Decision Records) para cada decisión significativa. Promover decisiones técnicas transversales a Reglas en el project-context.md.

**Límites:** NO añade requisitos funcionales, eso es trabajo del PM Agent. NO modifica el PRD. NO crea Skills, eso es trabajo del SM Agent. Si parece faltar un requisito funcional, lo señala al PM Agent.

**Reglas que aplica:** Todas las Reglas del project-context.md, con foco específico en stack tecnológico, restricciones de seguridad y reglas de integración.

**Protocolo ante gaps:** Cuando el PRD carece de detalle técnico necesario para una decisión de arquitectura, documentar el gap en el Architecture Document como "pregunta abierta" y señalarlo al Context Engineer. No asumir la respuesta.
:::

### Fidelidad descendente

Cada Agente transforma el output del anterior, pero nunca lo contradice, nunca lo enriquece con invención y nunca lo reinterpreta. Las Reglas de fidelidad aseguran que la cadena no degrada el contexto.

Piensa en ello como una carrera de relevos: cada corredor lleva el mismo testigo. Puede correr más rápido o más lento, pero no puede cambiar lo que hay dentro del testigo. Cuando el SM Agent crea los Skills finales, son fieles al Problem Statement original porque cada eslabón de la cadena fue gobernado por las mismas Reglas.

## Paso 3. Generar Documentos Estratégicos

*Duración estimada: 2-5 días (depende de la complejidad del proyecto)*

Entre las Reglas (capa global) y los Skills (capa de ejecución) hay una capa intermedia de documentos que definen el "qué" y el "cómo" a nivel de sistema.

### El PRD: qué construir y para quién

El PRD es la traducción del Solution Brief al lenguaje de los Agentes. Cada sección será consumida por Agentes específicos para producir Reglas adicionales o Skills concretos:

| Sección del PRD | Qué contiene | Agente que lo consume | Qué produce |
|---|---|---|---|
| **Visión y alcance** | Qué hace, qué no, para quién. | Architect + SM Agent | Reglas de alcance + Skills acotados. |
| **Casos de uso** | Trigger, flujo, resultado esperado. | SM Agent | Cada caso de uso genera uno o más Skills. |
| **Criterios de éxito** | KPIs medibles. | QA Agent | Criterios de aceptación para Skills de validación. |
| **Restricciones** | Técnicas, de negocio, regulatorias. | Architect Agent | Nuevas Reglas en project-context.md. |
| **Asunciones activas** | Lo dado por cierto sin verificar. | Todos los Agentes | Señales de riesgo en cada Skill afectado. |
| **Prioridades** | P0, P1, P2. | SM Agent | Secuencia de Skills: P0 primero, luego P1, luego P2. |

:::tip[Trazabilidad total]
Cada elemento del PRD tiene una fuente en la Fase 1 o 2. Cada Skill que genera el SM Agent traza al PRD. Cada Regla que genera el Architect traza al PRD. La cadena completa es: **Problem Statement → Solution Brief → PRD → Reglas + Skills.** Si un Skill no puede trazarse hasta el Problem Statement, es invención.
:::

### El Architecture Document: decisiones técnicas que se convierten en Reglas

El Architecture Document traduce el PRD a decisiones técnicas. Pero su función más crítica es otra: **las decisiones de arquitectura se convierten en Reglas globales.** Cuando el Architect Agent decide que todos los servicios se comunican vía gRPC, eso no es una decisión local, es una nueva Regla que todos los Agentes deben respetar en todos los Skills.

Por eso el Architect Agent es el único Agente que actualiza el project-context.md. Los demás lo leen; el Architect lo escribe.

El Architecture Document incluye:

- **ADRs (Architecture Decision Records):** Cada decisión con contexto, alternativas evaluadas, decisión tomada y consecuencias. Las decisiones transversales se promueven a Reglas.
- **Modelo de datos:** Entidades, relaciones, formato. Los Skills de desarrollo heredan este modelo vía las Reglas.
- **Estrategia de IA:** Tipo de modelo, estrategia de datos (RAG, fine-tuning, few-shot), pipeline, gobernanza. Define Reglas específicas para Agentes y Skills que interactúan con la IA.
- **Requisitos no funcionales:** Rendimiento, seguridad, observabilidad. Se traducen en Reglas de Nivel 4-5.

:::note Ejemplo práctico: Decisión de arquitectura que se convierte en Regla
El Architect Agent decide: "Todos los servicios se comunican vía REST con envelope JSON &#123; data, error, meta &#125;. Elegido sobre GraphQL por simplicidad dada la experiencia del equipo. Consecuencia: todos los Skills de API deben implementar este formato."

Este ADR se promueve a **Regla de Nivel 5** en el project-context.md. Ahora cada Agente que construya cualquier Skill de API hereda esta restricción automáticamente. La Regla lleva el "por qué" para que si surge una situación no cubierta, el Agente entienda el razonamiento.
:::

## Paso 4. Descomponer en Skills

*Duración estimada: 2-5 días*

Aquí es donde el SM Agent descompone todo (PRD, Architecture Document, Reglas) en tareas concretas que los Agentes de desarrollo ejecutarán. Cada Skill es una unidad de trabajo autocontenida, como una orden de trabajo que contiene todo lo que el trabajador necesita.

### Los cinco elementos de cada Skill

1. **Objetivo:** Qué debe lograrse. No cómo, sino qué. El Agente lo usa para tomar decisiones ante ambigüedades, dentro de las Reglas.
2. **Contexto específico:** Extractos del PRD y la Arquitectura. Solo lo que *este* Skill necesita. Complementa las Reglas globales con información específica de la tarea.
3. **Criterios de aceptación:** Condiciones verificables, escritas como assertions. El QA Agent las usa para validar el output.
4. **Dependencias:** Qué otros Skills deben estar completos antes. Los Agentes no ejecutan Skills fuera de secuencia.
5. **Restricciones específicas:** Limitaciones para esta tarea, adicionales a las Reglas globales. Si hay conflicto entre una restricción y una Regla, la Regla gana. Siempre.

### Tres tipos de Skills

| Tipo | Granularidad | Cuándo usarlo | Ejemplo |
|---|---|---|---|
| **Atómico** | Una tarea, un output. | La tarea es autocontenida y un Agente puede completarla en una interacción. | "Crear endpoint GET /inventory/&#123;sku&#125;." |
| **Compuesto** | Múltiples sub-tareas coordinadas. | Varias sub-tareas relacionadas comparten contexto y deben manejarse juntas. | "Módulo de alertas: modelo de datos + lógica de negocio + notificación." |
| **De integración** | Conecta outputs de otros Skills. | Dos o más Skills completados necesitan funcionar juntos. Las Reglas de integración del project-context.md son especialmente críticas. | "Integrar inventario con alertas, validar flujo e2e." |

### El test de autocontención

Para cada Skill, pregunta: **"¿Un Agente que lea solo este Skill y el project-context.md puede completar la tarea sin preguntar nada?"**

Si la respuesta es no, falta contexto. Añádelo al Skill, no asumas que el Agente ya lo sabe.

:::note Ejemplo práctico: Un Skill bien diseñado vs. uno mal diseñado
**Skill pobre:** "Construir el endpoint de inventario."
- Falta: ¿qué endpoint? ¿Qué datos? ¿Qué formato? ¿Qué manejo de errores? El Agente adivinará, y sus respuestas serán seguras pero potencialmente erróneas.

**Skill bien diseñado:**
- **Objetivo:** Crear un endpoint REST que devuelva el nivel de stock actual para un SKU dado.
- **Contexto:** El modelo de inventario usa `sku` (string, único) y `quantity` (entero). El modelo de datos está en el Architecture Document, sección 3.2.
- **Criterios de aceptación:** Devuelve 200 con &#123; data: &#123; sku, quantity, warehouse &#125;, error: null, meta: &#123; timestamp &#125; &#125;. Devuelve 404 para SKU desconocido. Tiempo de respuesta menor a 200ms.
- **Dependencias:** Skill del modelo de datos (S-003) debe estar completo.
- **Restricciones:** Las cantidades de stock siempre son enteros (Regla Nivel 5). Autenticación OAuth 2.0 requerida (Regla Nivel 5).
:::

## Paso 5. Validar a través de Outputs

*Duración estimada: 1-3 días*

El contexto no se valida revisando documentos. Se valida ejecutando el sistema y juzgando los resultados. Un conjunto perfecto de Reglas, Agentes bien definidos y Skills detallados puede producir outputs mediocres si la interacción entre los tres falla.

### El ciclo de validación

1. El Context Engineer presenta el sistema completo: Reglas (project-context.md), Agentes (definiciones), Skills (Story Files).
2. Los Agentes procesan Skills de muestra y producen outputs: código, diseños, decisiones.
3. Los stakeholders de las Fases 1 y 2 revisan los outputs.
4. La pregunta: **"¿Este output es reconocible como una expresión fiel del Problem Statement y el Solution Brief?"**
5. Si sí: contexto validado. Si no: el Context Engineer ajusta Reglas, Agentes o Skills y repite.

### Los cuatro flujos de interacción

Cuatro flujos mantienen vivo el sistema durante la validación y durante la Fase 4:

| Flujo | Dirección | Qué sucede | Ejemplo |
|---|---|---|---|
| **Gobernanza** | Reglas → Agentes | El Agente carga las Reglas como restricciones antes de ejecutar cualquier Skill. | "El project-context.md dice TypeScript + Express. El Dev Agent no puede usar Python en ningún Skill." |
| **Ejecución** | Agentes → Skills | El Agente recibe un Skill, lo procesa dentro de las Reglas, produce output. | "El Dev Agent recibe 'crear endpoint', aplica Reglas de formato JSON, entrega output." |
| **Feedback** | Skills → Reglas | Una decisión durante un Skill que debería ser global se escala y se convierte en Regla. | "El primer Skill de endpoint define un patrón de paginación. Se promueve a Regla para todos los Skills." |
| **Validación** | QA Agent → Todo | El QA verifica que cada Agente respeta las Reglas y que cada Skill produce outputs conformes. | "El QA detecta que un Skill produce un endpoint sin 'meta'. Viola Regla de Nivel 5. Se rechaza." |

### Diagnosticar fallos

Cuando los outputs no coinciden con las expectativas, identifica dónde está el problema:

| ¿Dónde está el problema? | Síntoma | Qué ajustar |
|---|---|---|
| **Las Reglas** | Múltiples Agentes producen el mismo tipo de error en distintos Skills. Las decisiones son inconsistentes entre sí. | Refinar Reglas del project-context.md. Falta una Regla o es demasiado vaga. |
| **Un Agente** | Un Agente falla en varios Skills. Otros Agentes con Skills similares no fallan. | Revisar identidad, responsabilidades y límites de ese Agente. La definición está incompleta. |
| **Un Skill** | Un output falla pero el Agente funciona bien en otros Skills. | Enriquecer el contexto específico de ese Skill. Le falta información que el Agente necesita. |
| **La interacción** | Cada Skill produce output correcto individualmente. El conjunto no funciona. | Revisar dependencias entre Skills y coherencia entre Reglas y Skills. |

:::tip Cuando los outputs sorprenden
La validación más reveladora es cuando un output es técnicamente correcto pero no "se siente bien" para los stakeholders. Esto suele señalar una Regla que falta, no un Agente roto. El Agente siguió todas las Reglas fielmente, el problema es que las Reglas no capturaban algo que el equipo asumía como obvio. Hazlo explícito, añade la Regla y ejecuta la validación de nuevo.
:::
